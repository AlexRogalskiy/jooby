# asset processor

Checks, validate and/or modify asset contents. An [AssetProcessor]({{defdocs}}/assets/AssetProcessor.html) is usually provided as a separated dependency.

## how to use it?

First thing to do is to add the dependency:

```xml
  <dependency>
    <groupId>org.jooby</groupId>
    <artifactId>jooby-assets-my-processor</artifactId>
    <scope>provided</scope>
  </dependency>
```

Did you see the **provided** scope? We just need the processor for development, because assets are processed at runtime. In ```prod```, assets are processed at built-time via Maven/Gradle plugin, so we don't need this library/dependency. This also, helps to keep our dependencies and the jar size small.

Now we have the dependency all we have to do is to add it to our pipeline:

```text
assets {
  pipeline: {
    dev: [my-processor]
  }
}
```

## configuration

It is possible to configure or set options too:

```text
assets {
  pipeline: {
    dev: [my-processor]
    dist: [my-processor]
  }
  my-processor {
    foo: bar
  }
}
```

Previous example, set a ```foo``` property to ```bar```! Options can be set per environment too:

```text
assets {
  pipeline: {
    dev: [my-processor]
    dist: [my-processor]
  }
  my-processor {
    dev {
      bar: bar
    }
    dist {
      foo: bar
    }
    foo: foo
  }
}
```

Here, in ```dev``` processor has two properties: ```foo:foo``` and ```bar:bar```, while in ```dist``` the processor only has ```foo:bar```

## binding

The ```my-processor``` will be resolved it to: ```org.jooby.assets.MyProcessor``` class. The processor name is converted to ```MyProcessor```, it converts the hyphenated name to upper camel and by default processors are defined in the ```org.jooby.assets``` package.

A custom binding is provided via the ```class``` property:

```text
assets {
  pipeline: {
    dev: [my-processor]
    dist: [my-processor]
  }
  my-processor {
    class: whatever.i.Want
  }
}
```

# asset aggregator

Contributes new or dynamically generated content to a ```fileset```. Content generated by an aggregator might be processed by an {@link AssetProcessor}.

## how to use it?

First thing to do is to add the dependency:

```xml
<dependency>
    <groupId>org.jooby</groupId>
    <artifactId>jooby-assets-dr-svg-sprites</artifactId>
    <scope>provided</scope>
  </dependency>

```

Did you see the **provided** scope? We just need the aggregator for development, because assets are processed at runtime. In ```prod```, assets are processed at built-time via Maven/Gradle plugin, so we don't need it. This also, helps to keep our dependencies and the jar size small.

Now we have the dependency all we have to do is to add the ```svg-sprites``` aggregator to a fileset:

```
assets {
  fileset {

    home: [
      // 1) Add the aggregator to a fileset
      svg-sprites,
      css/style.css,
      js/app.js
    ]
  }

  svg-sprites {
    // 2) The `css/sprite.css` file is part of the `home` fileset.
    spritePath: "css/sprite.css"
    spriteElementPath: "images/svg",
  }

}
```

Here for example, the ```svg-sprites``` aggregator contributes the ```css/sprite.css``` file to the ```home``` fileset. The fileset then looks like:

```
assets {
  fileset {
    home: [
      css/sprite.css,
      css/style.css,
      js/app.js
    ]
  }
}
```

It replaces the aggregator name with one or more files from [AssetAggregator.fileset]({{defdocs}}/assets/AssetAggregator.html#fileset--) method.

# available processors

{{available-asset-procesors.md}}
