== Dependency Injection

In Jooby 2.x there is no dependency injection framework. This is another major difference with 1.x which
was built with Guice.

This make Jooby 2.x more lightweight than 1.x but most important give you freedom of using the
dependency injection of your choice.

=== Dagger

1) Add Dagger 2 to your project

[dependency, groupId="com.google.dagger", artifactId="dagger", version="2.20"]
.

2) Configure annotation processor

.Maven
[source, xml, role = "primary"]
----
<build>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-compiler-plugin</artifactId>
      <version>...</version>
      <configuration>
        <annotationProcessorPaths>
          <path>
            <groupId>com.google.dagger</groupId>
            <artifactId>dagger-compiler</artifactId>
            <version>2.20</version>
          </path>
        </annotationProcessorPaths>
      </configuration>
    </plugin>
  </plugins>
</build>
----

.Gradle
[source, kotlin, role = "secondary"]
----
plugins {
  id "net.ltgt.apt" version "0.21"
}

dependencies {
  apt 'com.google.dagger:dagger-compiler:2.20'
}
----

3) Bootstrap Dagger from application:

.Dagger
[source, java, role = "primary"]
----
import static io.jooby.Jooby.runApp;

public class App {

  public static void main(String[] args) {
    runApp(args, app -> {
      /** Dagger: */
      AppComponent dagger = DaggerAppComponent.builder()      <1>
          .build();
      
      get("/", ctx -> {
        MyService service = dagger.getMyService();            <2>
        return service.doSomething();
      });
    });
  }
}
----

.Kotlin
[source, kotlin, role = "secondary"]
----
import io.jooby.runApp

fun main(args: Array<String>) {
  runApp(args) {
    val dagger = DaggerAppComponent.builder() <1>
        .build()
    
    get("/") { ctx ->
      val service = dagger.getMyService()     <2>
      service.doSomething()
    }
  }
}
----

<1> Bootstrap dagger component
<2> Use dagger provided objects

[id=dagger-mvc-routes]
==== MVC routes

Integration of MVC routes with Dagger is as simple as:

.MVC and Dagger
[source, java, role = "primary"]
----

import static io.jooby.Jooby.runApp;

public class App {

  public static void main(String[] args) {
    runApp(args, app -> {
      /** Dagger: */
      AppComponent dagger = DaggerAppComponent.builder()  <1>
          .build();
      
      mvc(dagger.myController());                         <2>
    });
  }
}
----

.Kotlin
[source, kotlin, role = "secondary"]
----
import io.jooby.runApp

fun main(args: Array<String>) {
  runApp(args) {
    val dagger = DaggerAppComponent.builder() <1>
        .build()
    
    mvc(dagger.myController())                <2>
  }
}
----

<1> Bootstrap dagger component
<2> Register MVC route provided by Dagger

Due the static nature of Dagger mvc integration identical to normal usage. For custom scopes/lifecycles
Dagger generate a `javax.inject.Provider` on such use cases you need to switch and use the provider
version of the `mvc` method:

.MVC and Dagger provider
[source, java, role = "primary"]
----
import static io.jooby.Jooby.runApp;

public class App {

  public static void main(String[] args) {
    runApp(args, app -> {
      /** Dagger: */
      AppComponent dagger = DaggerAppComponent.builder()      <1>
          .build();
      
      mvc(MyController.class, dagger.myController());         <2>
    });
  }
}
----

.Kotlin
[source, kotlin, role = "secondary"]
----
import io.jooby.runApp

fun main(args: Array<String>) {
  runApp(args) {
    val dagger = DaggerAppComponent.builder()        <1>
        .build()
    
    mvc(MyController::class, dagger.myController())  <2>
  }
}
----

<1> Bootstrap dagger component
<2> Register MVC route using a Dagger provider

=== Guice

1) Add Guice dependency to your project:

[dependency, artifactId="jooby-guice"]
.

2) Install Guice:

.Installing Guice
[source, java, role = "primary"]
----

import io.jooby.di.Guiceby;
import io.jooby.runApp;

public class App {

  public static void main(String[] args) {
    runApp(args, app -> {
      install(new Guiceby());                         <1>
      
      get("/", ctx -> {
        MyService service = require(MyService.class); <2>
        return service.doSomething();
      });
    });
  }
}
----

.Kotlin
[source, kotlin, role = "secondary"]
----
import io.jooby.di.Guiceby
import io.jooby.runApp

fun main(args: Array<String>) {
  runApp(args) {
    install(Guiceby())                        <1>
    
    get ("/") { ctx ->
      val service = require(MyService::class) <2>
      service.doSomething()
    }
  }
}
----

<1> Install Guice extension
<2> The javadoc:Jooby[require, java.lang.Class] call is now resolved by Guice

[id=guice-mvc-routes]
==== MVC routes

Guice will also provisioning MVC routes

.MVC and Guice
[source, java, role = "primary"]
----
import io.jooby.di.Guiceby;
import io.jooby.runApp

public class App extends Jooby {

  public static void main(String[] args) {
    runApp(args, app -> {
      install(new Guiceby());    <1>
      
      mvc(MyController.class);   <2>
    });
  }
}
----

.Kotlin
[source, kotlin, role = "secondary"]
----
import io.jooby.di.Guiceby
import io.jooby.runApp

fun main(args: Array<String>) {
  runApp(args) {
    install(Guiceby())         <1>

    mvc(MyController::class)   <2>
  }
}
----

<1> Install Guice extension
<2> Register a MVC route

The lifecycle of `MyController` is now managed by Guice. Also:

- In Guice, the default scope is `prototype` (creates a new instance per request)
- If you prefer a single instance add the `javax.inject.Singleton` annotation 

=== Spring

1) Add Spring dependency to your project:

[dependency, artifactId="jooby-spring"]
.

2) Install Spring:

.Installing Spring
[source, java, role = "primary"]
----
package myapp;                                        <1>

import static io.jooby.Jooby.runApp;
import io.jooby.di.Spring;

public class App {

  public static void main(String[] args) {
    runApp(args, app -> {
      app.install(new Spring());                       <2>
  
      app.get("/", ctx -> {
        MyService service = require(MyService.class);  <3>
        return service.doSomething();
      });
    });
  }
}
----

.Kotlin
[source, kotlin, role = "secondary"]
----
package myapp                                        <1>

import io.jooby.runApp
import io.jooby.di.Spring

fun main(args: Array<String>) {
  runApp(args) {

    install(new Spring())                            <2>

    get ("/") { ctx ->
      val service = require(MyService::class)        <3>
      service.doSomething()
    }
  }
}
----

<1> Spring scan the package `myapp` and subpackages
<2> Install Spring module
<3> The javadoc:Jooby[require, java.lang.Class] call is now resolved by Spring

Spring uses the application package and sub-packages to scan. If you need extra packages, provide them at creation time:

----
install(new Spring("foo", "bar"));
----

[id=spring-mvc-routes]
==== MVC routes

The Spring extension does a bit more in relation to MVC routes:

- A MVC route annotated with the `org.springframework.stereotype.Controller` annotation is
automatically registered. No need to register it manually

- A MVC route provided by Spring is a singleton object by default. Singleton is the default scope in Spring

.MVC route
[source, java, role="primary"]
----
import org.springframework.stereotype.Controller;

@Controller
public class Hello {

   @GET
   public String sayHi() {
     return "Hi Spring!";
   }
}
----

.Kotlin
[source, kotlin, role="secondary"]
----
import org.springframework.stereotype.Controller

@Controller
class Hello {

   @GET
   fun sayHi(): String {
     return "Hi Spring!"
   }
}
----

=== Weld

1) Add Weld dependency to your project:

[dependency, artifactId="jooby-weld"]
.

2) Install Weld:

.Installing Weld
[source, java, role = "primary"]
----
import io.jooby.di.Weldby;
import static io.jooby.Jooby.runApp;

public class App {

  public static void main(String[] args) {
    runApp(args, app -> {
      install(new Weldby());                          <1>
  
      get ("/", ctx -> {
        MyService service = require(MyService.class); <2>
        service.doSomething();
      });
    });
  }
}
----

.Kotlin
[source, kotlin, role = "secondary"]
----
import io.jooby.di.Weldby
import io.jooby.runApp

fun main(args: Array<String>) {
  runApp(args) {
    install(Weldby())                               <1>

    get ("/") { ctx ->
      val service = require(MyService::class)       <2>
      service.doSomething()
    }
  }
}
----

<1> Install Weld
<2> The javadoc:Jooby[require, java.lang.Class] call is now resolved by Weld

[id=weld-mvc-routes]
==== MVC routes

The Weld extension does a bit more in relation to MVC routes:

- A MVC route annotated with the `io.jooby.annotations.Controller` annotation is
automatically registered. No need to register it manually

- A MVC route provided by Weld is a singleton object by default. Singleton is the default scope in Weld

.MVC route
[source, java, role="primary"]
----
import io.jooby.annotations.*;

@Controller
public class Hello {

   @GET
   public String sayHi() {
     return "Hi Weld!";
   }
}
----

.Kotlin
[source, kotlin, role="secondary"]
----
import io.jooby.annotations.*;

@Controller
class Hello {

   @GET
   fun sayHi(): String {
     return "Hi Weld!"
   }
}
----
