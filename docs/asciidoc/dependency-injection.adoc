== Dependency Injection

In Jooby 2.x there is no dependency injection framework. This is another major difference with 1.x which
was built with Guice.

This make Jooby 2.x more lightweight than 1.x but most important give you freedom of using the
dependency injection of your choice.

=== Dagger

1) Add Dagger to your project

[dependency, groupId="com.google.dagger", artifactId="dagger", version="2.20"]
.

2) Configure annotation processor

.Maven
[source, xml, role = "primary"]
----
<build>
  <plugins>
    <plugin>
      <groupId>org.apache.maven.plugins</groupId>
      <artifactId>maven-compiler-plugin</artifactId>
      <version>...</version>
      <configuration>
        <annotationProcessorPaths>
          <path>
            <groupId>com.google.dagger</groupId>
            <artifactId>dagger-compiler</artifactId>
            <version>2.20</version>
          </path>
        </annotationProcessorPaths>
      </configuration>
    </plugin>
  </plugins>
</build>
----

.Gradle
[source, kotlin, role = "secondary"]
----
plugins {
  id "net.ltgt.apt" version "0.21"
}

dependencies {
  apt 'com.google.dagger:dagger-compiler:2.20'
}
----

3) Bootstrap Dagger from application:

.Dagger
[source, java, role = "primary"]
----
import static io.jooby.Jooby.runApp;

public class App extends Jooby {

  {
     /** Dagger: */
     AppComponent dagger = DaggerAppComponent.builder()      <1>
         .build();
      
     get("/", ctx -> {
       MyService service = dagger.getMyService();            <2>
       return service.doSomething();
     });
  }

  public static void main(String[] args) {
    runApp(args, App::new);
  }
}
----

.Kotlin
[source, kotlin, role = "secondary"]
----
import io.jooby.runApp

fun main(args: Array<String>) {
  runApp(args) {
    val dagger = DaggerAppComponent.builder() <1>
        .build()
    
    get("/") { ctx ->
      val service = dagger.getMyService()     <2>
      service.doSomething()
    }
  }
}
----

<1> Bootstrap dagger component
<2> Use dagger provided objects

[discrete]
==== MVC routes

Integration of MVC routes with Dagger is as simple as:

.MVC and Dagger
[source, java, role = "primary"]
----

import static io.jooby.Jooby.runApp;

public class App extends Jooby {

  {
    /** Dagger: */
    AppComponent dagger = DaggerAppComponent.builder()  <1>
        .build();
    
    mvc(dagger.myController());                         <2>
  }

  public static void main(String[] args) {
    runApp(args, App::new);
  }
}
----

.Kotlin
[source, kotlin, role = "secondary"]
----
import io.jooby.runApp

fun main(args: Array<String>) {
  runApp(args) {
    val dagger = DaggerAppComponent.builder() <1>
        .build()
    
    mvc(dagger.myController())                <2>
  }
}
----

<1> Bootstrap dagger component
<2> Register MVC route provided by Dagger

Due the static nature of Dagger mvc integration identical to normal usage. For custom scopes/lifecycles
Dagger generate a `javax.inject.Provider` on such use cases you need to switch and use the provider
version of the `mvc` method:

.MVC and Dagger provider
[source, java, role = "primary"]
----
import static io.jooby.Jooby.runApp;

public class App extends Jooby {

  {
    /** Dagger: */
    AppComponent dagger = DaggerAppComponent.builder()      <1>
        .build();
    
    mvc(MyController.class, dagger.myController());         <2>
  }

  public static void main(String[] args) {
    runApp(args, App::new);
  }
}
----

.Kotlin
[source, kotlin, role = "secondary"]
----
import io.jooby.runApp

fun main(args: Array<String>) {
  runApp(args) {
    val dagger = DaggerAppComponent.builder()        <1>
        .build()
    
    mvc(MyController::class, dagger.myController())  <2>
  }
}
----

<1> Bootstrap dagger component
<2> Register MVC route using a Dagger provider

=== Guice

1) Add Guice dependency to your project:

[dependency, artifactId="jooby-guice"]
.

2) Install Guice:

.Installing Guice
[source, java, role = "primary"]
----

import io.jooby.di.Guiceby;
import io.jooby.runApp;

public class App extends Jooby {

  {
    install(new Guiceby());                         <1>
        
    get("/", ctx -> {
      MyService service = require(MyService.class); <2>
      return service.doSomething();
    });
}

  public static void main(String[] args) {
    runApp(args, App::new);
  }
}
----

.Kotlin
[source, kotlin, role = "secondary"]
----
import io.jooby.di.Guiceby
import io.jooby.runApp

fun main(args: Array<String>) {
  runApp(args) {
    install(Guiceby())                        <1>
    
    get ("/") { ctx ->
      val service = require(MyService::class) <2>
      service.doSomething()
    }
  }
}
----

<1> Install Guice extension
<2> The javadoc:Jooby[require, java.lang.Class] call is now resolved by Guice

==== Property Injection

Configuration properties can be injected using the `@Named` annotation:

.application.conf
[source, bash]
----
currency = USD
----

.Java
[source,java,role="primary"]
----

import javax.injext.Named;
import javax.injext.Inject;

public class BillingService {

  @Inject
  public BillingService(@Named("currency") String currency) {
    ...
  }

}
----

.Kotlin
[source,kotlin,role="secondary"]
----
class BillingService @Inject constructor(@Named("currency") currency: String) {
  ...
}
----

==== MVC routes

Guice will also provisioning MVC routes

.MVC and Guice
[source, java, role = "primary"]
----
import io.jooby.di.Guiceby;
import io.jooby.runApp

public class App extends Jooby {

  {
    install(new Guiceby());    <1>
          
    mvc(MyController.class);   <2>
  }

  public static void main(String[] args) {
    runApp(args, App::new);
  }
}
----

.Kotlin
[source, kotlin, role = "secondary"]
----
import io.jooby.di.Guiceby
import io.jooby.runApp

fun main(args: Array<String>) {
  runApp(args) {
    install(Guiceby())         <1>

    mvc(MyController::class)   <2>
  }
}
----

<1> Install Guice extension
<2> Register a MVC route

The lifecycle of `MyController` is now managed by Guice. Also:

- In Guice, the default scope is `prototype` (creates a new instance per request)
- If you prefer a single instance add the `javax.inject.Singleton` annotation 

=== Spring

1) Add Spring dependency to your project:

[dependency, artifactId="jooby-spring"]
.

2) Install Spring:

.Installing Spring
[source, java, role = "primary"]
----
package myapp;                                       <1>

import static io.jooby.Jooby.runApp;
import io.jooby.di.Springby;

public class App extends Jooby {

  {
    install(new Springby());                         <2>
      
    get("/", ctx -> {
      MyService service = require(MyService.class);  <3>
      return service.doSomething();
    });
  }

  public static void main(String[] args) {
    runApp(args, App::new);
  }
}
----

.Kotlin
[source, kotlin, role = "secondary"]
----
package myapp                                        <1>

import io.jooby.runApp
import io.jooby.di.Springby

fun main(args: Array<String>) {
  runApp(args) {

    install(new Springby())                          <2>

    get ("/") { ctx ->
      val service = require(MyService::class)        <3>
      service.doSomething()
    }
  }
}
----

<1> Spring scan the package `myapp` and subpackages
<2> Install Spring module
<3> The javadoc:Jooby[require, java.lang.Class] call is now resolved by Spring

Spring uses the application package and sub-packages to scan. If you need extra packages, provide them at creation time:

----
install(new Spring("foo", "bar"));
----

==== Property Injection

Configuration properties can be injected using the `@Value` annotation:

.application.conf
[source, bash]
----
currency = USD
----

.Java
[source,java,role="primary"]
----
import javax.injext.Inject;
import org.springframework.beans.factory.annotation.Value;

public class BillingService {

  @Inject
  public BillingService(@Value("currency") String currency) {
    ...
  }

}
----

.Kotlin
[source,kotlin,role="secondary"]
----
import javax.injext.Inject
import org.springframework.beans.factory.annotation.Value

class BillingService @Inject constructor(@Value("${currency}") currency: String) {
  ...
}
----

==== MVC routes

The Spring extension does a bit more in relation to MVC routes:

- A MVC route annotated with the `org.springframework.stereotype.Controller` annotation is
automatically registered. No need to register it manually

- A MVC route provided by Spring is a singleton object by default. Singleton is the default scope in Spring

.MVC route
[source, java, role="primary"]
----
import org.springframework.stereotype.Controller;

@Controller
public class Hello {

   @GET
   public String sayHi() {
     return "Hi Spring!";
   }
}
----

.Kotlin
[source, kotlin, role="secondary"]
----
import org.springframework.stereotype.Controller

@Controller
class Hello {

   @GET
   fun sayHi(): String {
     return "Hi Spring!"
   }
}
----

=== Weld

1) Add Weld dependency to your project:

[dependency, artifactId="jooby-weld"]
.

2) Install Weld:

.Installing Weld
[source, java, role = "primary"]
----
import io.jooby.di.Weldby;
import static io.jooby.Jooby.runApp;

public class App extends Jooby {

  {
    install(new Weldby());                          <1>
      
    get ("/", ctx -> {
      MyService service = require(MyService.class); <2>
      service.doSomething();
    });
  }

  public static void main(String[] args) {
    runApp(args, App::new);
  }
}
----

.Kotlin
[source, kotlin, role = "secondary"]
----
import io.jooby.di.Weldby
import io.jooby.runApp

fun main(args: Array<String>) {
  runApp(args) {
    install(Weldby())                               <1>

    get ("/") { ctx ->
      val service = require(MyService::class)       <2>
      service.doSomething()
    }
  }
}
----

<1> Install Weld
<2> The javadoc:Jooby[require, java.lang.Class] call is now resolved by Weld

==== Property Injection

Configuration properties can be injected using the `@Named` annotation:

.application.conf
[source, bash]
----
currency = USD
----

.Java
[source,java,role="primary"]
----
import javax.injext.Inject;
import javax.injext.Named;

public class BillingService {

  @Inject
  public BillingService(@Named("currency") String currency) {
    ...
  }

}
----

.Kotlin
[source,kotlin,role="secondary"]
----
import javax.injext.Inject
import javax.injext.Named

class BillingService @Inject constructor(@Named("currency") currency: String) {
  ...
}
----

==== MVC routes

The Weld extension does a bit more in relation to MVC routes:

- A MVC route annotated with the `io.jooby.annotations.Path` annotation is
automatically registered. No need to register it manually

- The default scope is `prototype` (creates a new instance per request). If you prefer a single 
instance add the `javax.inject.Singleton` annotation

.MVC route
[source, java, role="primary"]
----
import io.jooby.annotations.*;

@Path("/")
public class Hello {

   @GET
   public String sayHi() {
     return "Hi Weld!";
   }
}
----

.Kotlin
[source, kotlin, role="secondary"]
----
import io.jooby.annotations.*;

@Path("/")
class Hello {

   @GET
   fun sayHi(): String {
     return "Hi Weld!"
   }
}
----
