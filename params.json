{"name":"jooby","tagline":"An Express inspired web framework for Java 8 (or higher).","body":"jooby\r\n=====\r\nAn Express inspired web framework for Java 8 (or higher).\r\n\r\n```java\r\n\r\nimport org.jooby.Jooby;\r\n\r\npublic class App extends Jooby {\r\n\r\n  {\r\n    get(\"/\", (req, res) ->\r\n      res.send(\"Hey Jooby!\")\r\n    );\r\n  }\r\n\r\n  public static void main(final String[] args) throws Exception {\r\n    new App().start();\r\n  }\r\n}\r\n\r\n```\r\n\r\nstatus\r\n=====\r\nversion: 0.1.0-SNAPSHOT\r\n\r\n\r\nrequirements\r\n=====\r\n* Java 8\r\n* Maven 3.x\r\n\r\n\r\nquickstart\r\n=====\r\n\r\nJust paste this into a terminal:\r\n\r\n    mvn archetype:generate -DgroupId=[app package] -DartifactId=[app name] -Dversion=[app version] -B -DarchetypeArtifactId=jooby-archetype -DarchetypeGroupId=org.jooby -DarchetypeVersion=0.1.0-SNAPSHOT\r\n\r\nYou must provide a value for:\r\n\r\n* -DgroupId: like ```com.mycompany```, ```org.myorg```, etc... It must be a valid Java package's name.\r\n\r\n* -DartifactId: like ```my-app```, usually in lower case and without spaces.\r\n\r\n* -Dversion: like ```1.0-SNAPSHOT``` or ```1.0.0-SNAPSHOT```\r\n\r\n\r\nLet's try it!:\r\n\r\n    mvn archetype:generate -B -DgroupId=com.mycompany -DartifactId=my-app -Dversion=1.0.0-SNAPSHOT -DarchetypeArtifactId=jooby-archetype -DarchetypeGroupId=org.jooby -DarchetypeVersion=0.1.0-SNAPSHOT\r\n    cd my-app\r\n    mvn jooby:run\r\n\r\nYou should see something similar to this at the end of the output:\r\n\r\n    INFO  [2014-10-27 16:40:17,241] Logging initialized @3193ms\r\n    INFO  [2014-10-27 16:40:17,321] jetty-9.2.3.v20140905\r\n    INFO  [2014-10-27 16:40:17,340] Started o.e.j.s.h.ContextHandler@604616a9{/,null,AVAILABLE}\r\n    INFO  [2014-10-27 16:40:17,357] Started ServerConnector@55802087{HTTP/1.1}{0.0.0.0:8090}\r\n    INFO  [2014-10-27 16:40:17,358] Started @3314ms\r\n    INFO  [2014-10-27 16:40:17,358]\r\n    Routes:\r\n      GET /assets/**/*    [*/*]     [*/*]    (static files)\r\n      GET /               [*/*]     [*/*]    (anonymous)\r\n\r\nOpen a browser and type:\r\n\r\n    http://localhost:8080/\r\n\r\nJooby! is up and running!!!\r\n\r\ncontents (work in progress)\r\n=====\r\n\r\n- [getting started](#getting-started)\r\n  - [exploring the newly created project](#exploring the newly created project)\r\n    - [directory layout](#directory layout)\r\n    - [App.java](#App.java)\r\n    - [running](#running)\r\n- [overview](#overview)\r\n- [routes](#routes)\r\n  - [path patterns](#path patterns)\r\n    - [variables](#variables)\r\n  - [type of routes](#type of routes)\r\n    - [inline](#inline)\r\n    - [external](#external)\r\n    - [mvc routes](#mvc routes)\r\n  - [router vs filter](#router vs filter)\r\n  - [request params](#request params)\r\n    - [param types](#param types)\r\n      - [path](#path)\r\n      - [query](#query)\r\n      - [body](#body)\r\n    - [param precedence](#param precedence)\r\n    - [optional params](#optional params)\r\n  - [request headers](#request headers)\r\n\r\ngetting started\r\n=====\r\n\r\nexploring the newly created project\r\n=====\r\n\r\ndirectory layout\r\n-----\r\n\r\nA new directory was created: ```my-app```. Now, let's see how it looks like:\r\n\r\n    /public\r\n           /assets/js/index.js\r\n           /assets/css/style.css\r\n           /images\r\n          welcome.html\r\n    /config\r\n           application.conf\r\n           logback.xml\r\n    /src/main/java\r\n                  /com/mycompany/App.java\r\n\r\nThe **public** directory contains ```*.html```, ```*.js```, ```*.css```, ```*.png```, ... etc., files.\r\n\r\nThe **config** directory contains ```*.conf```, ```*.properties```, ```*.json```, ... etc., files.\r\n\r\nThe **src/main/java** contains ```*.java``` (of course) files.\r\n\r\n**NOTE**: The three directory are part of the classpath.\r\n\r\n**NOTE**: So this is Maven, Why don't use the default directory layout?\r\n\r\nGood question, Java backend developers usually work with frontend developers and they wont have to look\r\ndeeply in the layout to find the resources they need (src/main/resources or src/main/webapp).\r\n\r\nThis is a matter of taste and if you find it problematic, you can just use the default directory layout of Maven.\r\n\r\n\r\nApp.java\r\n-----\r\n\r\n\r\n```java\r\n\r\nimport org.jooby.Jooby;\r\n\r\npublic class App extends Jooby {\r\n\r\n  {\r\n    assets(\"/assets/**\"); // 1. static files under assets\r\n\r\n    get(\"/\", html(\"welcome.html\")); // 2. default route\r\n  }\r\n\r\n  public static void main(final String[] args) throws Exception {\r\n    new App().start(); // 3. start the application.\r\n  }\r\n\r\n}\r\n\r\n```\r\n\r\nIt is pretty simple to add/configure a Jooby application. Steps involved are:\r\n\r\n1) extends Jooby\r\n\r\n2) define some routes\r\n\r\n3) call the ```start``` method\r\n\r\nrunning\r\n-----\r\nJust open a console and type:\r\n\r\n    mvn jooby:run\r\n\r\nThe plugin will compile the code if necessary and startup the application.\r\n\r\nOf course, you can generate the IDE metadata from Maven and/or import as a Maven project on the IDE of your choice. The all you have to do is run the:\r\n\r\n    App.java\r\n\r\nclass. After all, it is plain Java with a ```main``` method.\r\n\r\n## overview\r\n\r\nJooby is an [Express](http://expressjs.com/) inspired micro web framework for Java 8 (or higher).\r\n\r\nJooby API mimics (as much as possible) the [Express API](http://expressjs.com/4x/api.html).\r\n\r\nAPI is short and easy to learn, around 30 classes.\r\nThe most notable classes are: [Jooby.Module], [Route] and [WebSocket].\r\n\r\n### dependencies\r\n  * [Jetty](https://www.eclipse.org/jetty/) as HTTP NIO Web Server\r\n  * [Guice](https://github.com/google/guice) for Dependency Injection\r\n  * [Config](https://github.com/typesafehub/config) for a powerful config system\r\n\r\nJooby is organized as a set of reusable modules (a.k.a middleware in [Express](http://expressjs.com/)).\r\nA module does as minimum as possible and it should NOT make strong/hard decisions for you, or when it does, it must be 100% configurable.\r\nFor example, a module for the popular [Hibernate]() library should do:\r\n\r\n1) create a session factory\r\n\r\n2) expose a way to control transactions\r\n\r\n3) expose raw Hibernate API\r\n\r\nbut NOT:\r\n\r\n1) wrap/translate Hibernate exceptions\r\n\r\n2) wrap Hibernate API or similar\r\n\r\nIf a module does as minimum as possible, developers have the power! of setup/configure or take real advantage of native library features without noise.\r\n\r\n\r\n## routes\r\n\r\nLike in [Express](http://expressjs.com/) routes can be chained/stacked and executed in the same order they are defined.\r\n\r\nA route is represent by [Route] and there are two types of handlers: [Router] and [Filter].\r\n\r\nA handler is basically the callback executed while a route is the whole thing: verb, path, handler, etc...\r\n\r\n\r\n```java\r\n  {\r\n     get(\"/\", (req, res) ->\r\n       log.info(\"first\")\r\n     );\r\n\r\n     get(\"/\", (req, res) ->\r\n       log.info(\"second\")\r\n     );\r\n\r\n     get(\"/\", (req, res) ->\r\n       res.send(\"last\")\r\n     );\r\n  }\r\n```\r\n\r\nA call to:\r\n\r\n    http://localhost:8080\r\n\r\nwill print\r\n\r\n    first\r\n    second\r\n\r\nand display: ```last``` in the browser\r\n\r\n### path patterns\r\n\r\nJooby supports Ant-style path patterns:\r\n\r\n\r\n  ```com/t?st.html``` - matches ```com/test.html``` but also ```com/tast.html``` and ```com/txst.html```\r\n\r\n  ```com/*.html``` - matches all ```.html``` files in the ```com``` directory\r\n\r\n  ```com/**/test.html``` - matches all ```test.html``` files underneath the ```com``` path\r\n\r\n  ```**/*``` - matches any path at any level\r\n\r\n  ```*``` - matches any path at any level, shorthand for ```**/*```\r\n\r\n##### variables\r\n\r\nIn addition to Ant-style path pattern, variables pattern are also possible:\r\n\r\n  ```/user/{id}``` - matches ```/user/*``` and give you access to the ```id``` var\r\n\r\n  ```/user/:id``` - matches ```/user/*``` and give you access to the ```id``` var\r\n\r\n  ```/user/{id:\\\\d+}``` - /user/[digits] and give you access to the numeric ```id``` var\r\n\r\n```java\r\n  {\r\n     get(\"/users/:id\", (req, res) ->\r\n       res.send(req.param(\"id\").stringValue())\r\n     );\r\n\r\n    // or with braces\r\n    get(\"/users/{id}\", (req, res) ->\r\n       res.send(req.param(\"id\").stringValue())\r\n    );\r\n  }\r\n```\r\n\r\n### type of routes\r\nRoutes are classified in 3 groups: 1) inline; 2) external; or 3) Mvc routes.\r\n\r\nWe will cover inline vs external routes here and Mvc routes are covered later.\r\n\r\n#### inline\r\nInline routes use lambdas and are useful for quickstart and/or small/simple applications.\r\n\r\n```java\r\n{\r\n  get(\"/\", (req, res) -> res.send(req.path()));\r\n\r\n  post(\"/\", (req, res) -> res.send(req.path()));\r\n\r\n  ... etc...\r\n}\r\n\r\n```\r\n\r\n#### external\r\nExternal routes are declared in a separated class and looks like:\r\n\r\n```java\r\n{\r\n  get(\"/\", new ExternalRoute());\r\n}\r\n\r\n...\r\npublic class ExternalRoute implements Router {\r\n\r\n  public void handle(Request req, Response res) throws Exeption {\r\n    res.send(req.path());\r\n  }\r\n\r\n}\r\n```\r\n\r\nOf course this is also possible with Java 8:\r\n\r\n```java\r\n{\r\n  // static external route\r\n  get(\"/\", ExternalRoute::callback);\r\n}\r\n\r\n...\r\npublic class ExternalRoute {\r\n\r\n  public static void callback(Request req, Response res) throws Exeption {\r\n    res.send(req.path());\r\n  }\r\n}\r\n```\r\n\r\n#### mvc routes\r\nMvc routes are very similar to controllers in [Spring](http://spring.io/) or resources in [Jersey](https://jersey.java.net/).\r\nThey are covered later.\r\n\r\n### router vs filter\r\n\r\nThere are two types of handlers [Router] and [Filter]. The difference between them rely in the way\r\nthey allow/denied the execution of the next route in the chain. The next examples are identical:\r\n\r\n```java\r\n  {\r\n     get(\"/\", (req, res) -> {\r\n       log.info(\"first\");\r\n     });\r\n\r\n     get(\"/\", (req, res) -> {\r\n       log.info(\"second\");\r\n     });\r\n\r\n     get(\"/\", (req, res) ->\r\n       res.send(\"last\")\r\n     );\r\n  }\r\n```\r\n\r\n```java\r\n  {\r\n     get(\"/\", (req, res, chain) -> {\r\n       log.info(\"first\");\r\n       chain.next(req, res);\r\n     });\r\n\r\n     get(\"/\", (req, res, chain) -> {\r\n       log.info(\"second\");\r\n       chain.next(req, res);\r\n     });\r\n\r\n     get(\"/\", (req, res) ->\r\n       res.send(\"last\")\r\n     );\r\n  }\r\n```\r\n\r\nA [Router] **always** call the next route in the chain, while a [Filter] might or mightn't call the next route in chain.\r\n\r\n### request params\r\n\r\nThe API for retriving a param is defined by:\r\n\r\n    req.param(\"name\")\r\n\r\n**Always** returns a [Variant](https://github.com/jooby-project/jooby/blob/master/jooby/src/main/java/org/jooby/Variant.java).\r\nIf the param is missing or type conversion fails, a ```400 Bad Request``` response will be generated.\r\nYou can test the presence of param using [Variant.isPresent()](https://github.com/jooby-project/jooby/blob/master/jooby/src/main/java/org/jooby/Variant.java#L345)\r\n\r\nRequest params are plain string (or bytes). Params convertion is done sing these rules:\r\n\r\n1) Be a primitive type/ or primitive wrapper\r\n\r\n2) Have a static method named ```valueOf```, ```fromString```, ```forName```\r\n\r\n3) Be an [Upload](https://github.com/jooby-project/jooby/blob/master/jooby/src/main/java/org/jooby/Upload.java).\r\n\r\n4) Have a custom [Guice Type Converter](https://github.com/google/guice/wiki/CustomInjections)\r\n\r\n5) Be List<T>, Set<T> or SortedSet<T>, where T satisfies 1, 2 or 3 above. The resulting collection is read-only.\r\n\r\n6) Be Optional<T>, where T satisfies 1, 2, 3 or 4.\r\n\r\n#### param types\r\n\r\n##### path\r\nPath params also belong to the requested URI, but they looks like: ```/user:id``` or ```/user/{id}```\r\n\r\n    String id = req.param(\"id\").stringValue();\r\n\r\n##### query\r\nQuery params also belong to the requested URI, but they looks like: ```/user?id=123```\r\n\r\n    String id = req.param(\"id\").stringValue();\r\n\r\n##### body\r\nForm params are available when a ```application/x-www-form-urlencoded``` or ```multipart/form-data``` request is processed.\r\n\r\n    String id = req.param(\"id\").stringValue();\r\n\r\nThe same API works for file uploads:\r\n\r\n   Upload upload = req.param(\"myfile\").to(Upload.class);\r\n\r\nAnd/or body parts:\r\n\r\n   // multipart request named: jsonObject with a content type of application/json\r\n   MyObject object = req.param(\"jsonObject\").to(MyObject.class);\r\n\r\n#### param precedence\r\nParam resolution is done in this order:\r\n\r\n1) path\r\n\r\n2) query\r\n\r\n3) body (form/multipart)\r\n\r\nFor example:\r\n\r\n    curl -X POST -d \"name=third\" http://localhost:8080/user/first?name=second\r\n\r\nGive us:\r\n\r\n    get(\"/user:name\", (req, res) -> {\r\n      List<String> name = req.param(\"name\").toList(String.class);\r\n      // path\r\n      assertEquals(\"first\", name.get(0));\r\n      // query\r\n      assertEquals(\"second\", name.get(1));\r\n      // body\r\n      assertEquals(\"third\", name.get(2));\r\n    });\r\n\r\nAnd of course this is a valid call (no error):\r\n\r\n    assertEquals(\"first\", req.param(\"name\").stringValue());\r\n\r\nThis is supported, but try to avoid this from your APIs because it is hard to read/follow.\r\n\r\n#### optional params\r\nParam are required by default, if you need/require an optional param, just use:\r\n\r\n   Optional<String> optString = req.param(\"name\").toOptional(String.class);\r\n\r\n### request headers\r\nIt's identical on how request params work, except that API call is:\r\n\r\n    String header = req.header(\"header\").stringValue();\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}